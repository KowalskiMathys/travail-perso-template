# Résolution d’un sudoku par métaheuristique
Puisque l’on cherche à résoudre un sudoku à l’aide d’un algorithme métaheuristique, ne serait-il pas pertinent de s’attarder sur la définition du problème en lui-même ? Ce problème de résolution entre dans la catégorie des problèmes d’optimisations combinatoire – type de problèmes que permet notamment de résoudre le recuit simulé.  On parle de problèmes d’optimisations lorsque l’on cherche à optimiser une fonction sur un ensemble, nous définirons cette fonction par la suite. Il s’agit ici d’un problème d’optimisation combinatoire, car l’on cherche à trouver une structure de points éparpillé parmi un ensemble de tel structure. Le problème est bien combinatoire et discret car le problème s’étudie sur un ensemble finis et que la structure s’articule autour de plusieurs points éparpillé et non relié. 

Afin de facilité la lecture de la grille de sudoku, nous allons attribué à ces coté et colonnes un chiffres i et j permettant de faire référence à une case par ces deux composantes i et j. 

## Résolution de sudoku par Hill Climbing
Afin de résoudre un sudoku en usant de la méthode du Hill climbing, trois choses sont à définir. L’état de départ, la fonction de voisinage, et la fonction d’heuristique.

Appliquons à présent la théorie vu et étudié précédemment à notre sudoku.  Commençons par définir l’ensemble des solutions : Il s’agit de l’ensemble des grilles de 9x9 cases. Chacune de ces cases contient un chiffre de 1 à 9 quelconque à l’exceptions des cases fixes puisqu’elles sont… fixes. De plus ces cases fixes servent en réalité à définir l’instance. Par ailleurs, deux sudoku, basé sur les mêmes règles, ne se différencie que par leur cases fixes. Pour qu’une solution soit valide, l’on va procéder à une simple validation. Soit une case ω de coordonnées (i ; j). Une solution est valide et acceptable lorsque le nombre d’occurrence du chiffre de ω sans s’inclure lui-même est nulle, que ce soit en ligne, colonne ou dans la grille de 3x3 à laquelle appartient ω . 

Pour ce qui est du voisinage, deux solutions sont voisines si l’on peut obtenir l’une en changeant le chiffre contenu dans une seul case de l’autre, à condition que la case ne soit pas fixe évidemment. L’état de départ pour sa part sera défini aléatoirement en remplissant les cases vides de chiffres de 1 à 9. Finalement, la fonction d’heuristique consiste à calculer le nombre de doublons se trouvant dans chaque ligne et colonne, puis il s’agira de se concentrer sur la zone possédant le plus de doublons pour en rechercher les voisins de l’état actuelle et de tenter de réduire le nombre de doublons provoqué par la zone.

Evidemment, même si le remplissage se fait aléatoirement, il faut au préalable définir l’ensemble des chiffres disponibles. Puisque l’algorithme va ensuite mélanger les chiffres, il faut auparavant s’assurer qu’il y ait le bon nombre de 1, le bon nombre de 2, le bon nombre de 3, etc. En plus de cela, il faut nous demander de quel manière les chiffres seront distribué dans la grille. Puisque de toute façon, il nous faut compter quel chiffres sont présent dans les cases fixes afin des les retirer de la liste des chiffres disponibles, autant faire d’une pierre deux coup et distribué les chiffres de 1 à 9 dans les grilles de 3x3 afin de ne pas avoir à se préoccuper de la répartition des chiffres dans les grilles de 3x3. En effet si l’on distribue les chiffres inégalement à travers la grille, cela compliquera grandement le travail à effectuer par la suite. Or si dès l’état de base, toutes les grilles sont remplies de chiffres de 1 à 9, cela permet de se concentrer sur le nombre de doublons par ligne et par colonne et de faire abstraction des grilles de 3x3.  

### Exemple détailler de résolution par Hill climbing
A compléter avec des images et légendes

## Résolution de sudoku par Random-Restart hill climbing
Le fait que l’algorithme puisse se coincer dans un maximum local est un véritable problème pour nous. En effet, comme établis précédemment, un sudoku n’est sensé n’avoir qu’une solution ce qui implique que la résolution n’est accomplis que lorsque la solution est trouvé. Cette solution unique correspond donc à un optimum, l’optimum le plus haut. Or si l’on se retrouve coincé plus bas, cet solution candidate ne seras pas du tout satisfaisante. C’est pourquoi afin de ne pas être bloqué, nous allons appliquer une métaheuristique par-dessus l’algorithme de hill climbing. Afin de ne pas rester bloqué, il nous suffit de donner comme condition que, lorsque l’heuristique n’as pas progresser vers l’optimum depuis un certains temps t, l’on recommence l’algorithme avec un autre état de départ. De cette façon cela permet de contourner l’éventualité de rester coincé sur un optimum local. 

### Exemple détailler de résolution par Random-Restart Hill climbing
A compléter avec des images et légendes