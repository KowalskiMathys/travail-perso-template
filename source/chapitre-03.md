# Résolution d’un sudoku par métaheuristique
Puisque l’on cherche à résoudre un sudoku à l’aide d’un algorithme métaheuristique, ne serait-il pas pertinent de s’attarder sur la définition du problème en lui-même ? Ce problème de résolution entre dans la catégorie des problèmes d’optimisations combinatoire – type de problèmes que permet notamment de résoudre le recuit simulé.  On parle de problèmes d’optimisations lorsque l’on cherche à optimiser une fonction sur un ensemble, nous définirons cette fonction par la suite. Il s’agit ici d’un problème d’optimisation combinatoire, car l’on cherche à trouver une structure de points éparpillé parmi un ensemble de tel structure. Le problème est bien combinatoire et discret car le problème s’étudie sur un ensemble finis et que la structure s’articule autour de plusieurs points éparpillé et non relié. 

## Résolution de sudoku par Hill Climbing
Afin de résoudre un sudoku en usant de la méthode du Hill climbing, trois choses sont à définir. L’état de départ, la fonction de voisinage, et la fonction d’heuristique.

Appliquons à présent la théorie vu et étudié précédemment à notre sudoku.  Commençons par définir l’ensemble des solutions : Il s’agit de l’ensemble des grilles de 9x9 cases. Chacune de ces cases contient un chiffre de 1 à 9 quelconque à l’exceptions des cases fixes puisqu’elles sont… fixes. De plus ces cases fixes servent en réalité à définir l’instance. Par ailleurs, deux sudoku, basé sur les mêmes règles, ne se différencie que par leur cases fixes. Pour qu’une solution soit valide, l’on va procéder à une simple validation. Une solution est valide lorsque qu’elle n’as aucune erreur. Deux approche sont possible. On pourrait premièrement compter le nombre d’erreur ainsi que le montre l’image de dessous.

```{figure} figures/sudokuetat.png
---
width: 50%
---
Illustration d'un état dans le contexte du sudoku.
```

La deuxième approche - soit celle utilisée dans l’implémentation au prochain chapitre – consiste à compter le nombre de case valide. Autrement dit, cette optique va compter le nombre de case qui ne pose aucun problème tel que deux même chiffre dans la même colonne, ligne ou grille de 3x3. Pour ce qui est du voisinage, deux solutions sont voisines si l’on peut obtenir l’une en changeant le chiffre contenu dans une seul case de l’autre, à condition que la case ne soit pas fixe évidemment. L’état de départ pour sa part sera défini aléatoirement en remplissant les cases vides de chiffres de 1 à 9.  

Evidemment, même si le remplissage se fait aléatoirement, il faut au préalable définir l’ensemble des chiffres disponibles. Puisque l’algorithme va ensuite mélanger les chiffres, on pourrait auparavant s’assurer qu’il y ait le bon nombre de 1, le bon nombre de 2, le bon nombre de 3, etc. En plus de cela, il faut nous demander de quel manière les chiffres seront distribué dans la grille. Puisque de toute façon, il nous faut compter quel chiffres sont présent dans les cases fixes afin des les retirer de la liste des chiffres disponibles, autant faire d’une pierre deux coup et distribué les chiffres de 1 à 9 dans les grilles de 3x3 afin de ne pas avoir à se préoccuper de la répartition des chiffres dans les grilles de 3x3. En effet si l’on distribue les chiffres inégalement à travers la grille, cela compliquera grandement le travail à effectuer par la suite. Or si dès l’état de base, toutes les grilles sont remplies de chiffres de 1 à 9, cela permet de se concentrer sur le nombre de doublons par ligne et par colonne et de faire abstraction des grilles de 3x3.  

## Résolution de sudoku par Random-Restart hill climbing
Le fait que l’algorithme puisse se coincer dans un maximum local est un véritable problème pour nous. En effet, comme établis précédemment, un sudoku n’est sensé n’avoir qu’une solution ce qui implique que la résolution n’est accomplie que lorsque la solution est trouvée. Cette solution unique correspond donc à un optimum, l’optimum le plus haut. Or si l’on se retrouve coincé plus bas, cet solution candidate ne seras pas du tout satisfaisante. C’est pourquoi afin de ne pas être bloqué, nous allons appliquer une métaheuristique par-dessus l’algorithme de hill climbing. Afin de ne pas rester bloqué, il nous suffit de donner comme condition que, lorsque l’heuristique n’as pas progresser vers l’optimum depuis un certain temps t, l’on recommence l’algorithme avec un autre état de départ. De cette façon cela permet de contourner l’éventualité de rester coincé sur un optimum local. 